<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>FLTK 3.0: Multithreading support functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FLTK 3.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Multithreading support functions</div>  </div>
</div><!--header-->
<div class="contents">

<p>fl multithreading support functions declared in &lt;<a class="el" href="run_8h.html" title="fltk3 namespace ">fltk3/run.h</a>&gt;  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga57ad2446eb494e5e235b268008ad1be4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga57ad2446eb494e5e235b268008ad1be4">fltk3::awake</a> (void *message=0)</td></tr>
<tr class="memdesc:ga57ad2446eb494e5e235b268008ad1be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message pointer to the main thread, causing any pending <a class="el" href="namespacefltk3.html#a541733012d24b25a080b88dabcc03ece" title="Waits until &quot;something happens&quot; and then returns. ">fltk3::wait()</a> call to terminate so that the main thread can retrieve the message and any pending redraws can be processed.  <a href="#ga57ad2446eb494e5e235b268008ad1be4">More...</a><br/></td></tr>
<tr class="separator:ga57ad2446eb494e5e235b268008ad1be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa02c22e313b4819ebd65a0adc8ffc6e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#gaa02c22e313b4819ebd65a0adc8ffc6e8">fltk3::awake</a> (<a class="el" href="group__callback__functions.html#ga6d4af15d7c2d6deba77849428dfe21a6">fltk3::AwakeHandler</a> cb, void *message=0)</td></tr>
<tr class="memdesc:gaa02c22e313b4819ebd65a0adc8ffc6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">See void awake(void* message=0).  <a href="#gaa02c22e313b4819ebd65a0adc8ffc6e8">More...</a><br/></td></tr>
<tr class="separator:gaa02c22e313b4819ebd65a0adc8ffc6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3766ea2ba299968d3127970c06e0f88f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga3766ea2ba299968d3127970c06e0f88f">fltk3::lock</a> ()</td></tr>
<tr class="memdesc:ga3766ea2ba299968d3127970c06e0f88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#ga3766ea2ba299968d3127970c06e0f88f" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> method blocks the current thread until it can safely access FLTK widgets and data.  <a href="#ga3766ea2ba299968d3127970c06e0f88f">More...</a><br/></td></tr>
<tr class="separator:ga3766ea2ba299968d3127970c06e0f88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfd58519b3043a9a3625c79d9b156a40"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#gacfd58519b3043a9a3625c79d9b156a40">fltk3::thread_message</a> ()</td></tr>
<tr class="memdesc:gacfd58519b3043a9a3625c79d9b156a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#gacfd58519b3043a9a3625c79d9b156a40" title="The thread_message() method returns the last message that was sent from a child by the awake() method...">thread_message()</a> method returns the last message that was sent from a child by the <a class="el" href="group__fl__multithread.html#ga57ad2446eb494e5e235b268008ad1be4" title="Sends a message pointer to the main thread, causing any pending fltk3::wait() call to terminate so th...">awake()</a> method.  <a href="#gacfd58519b3043a9a3625c79d9b156a40">More...</a><br/></td></tr>
<tr class="separator:gacfd58519b3043a9a3625c79d9b156a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d3d4965696f433c45ace9ff9895fa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga07d3d4965696f433c45ace9ff9895fa0">fltk3::unlock</a> ()</td></tr>
<tr class="memdesc:ga07d3d4965696f433c45ace9ff9895fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#ga07d3d4965696f433c45ace9ff9895fa0" title="The unlock() method releases the lock that was set using the lock() method. ">unlock()</a> method releases the lock that was set using the <a class="el" href="group__fl__multithread.html#ga3766ea2ba299968d3127970c06e0f88f" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> method.  <a href="#ga07d3d4965696f433c45ace9ff9895fa0">More...</a><br/></td></tr>
<tr class="separator:ga07d3d4965696f433c45ace9ff9895fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>fl multithreading support functions declared in &lt;<a class="el" href="run_8h.html" title="fltk3 namespace ">fltk3/run.h</a>&gt; </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga57ad2446eb494e5e235b268008ad1be4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fltk3::awake </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message pointer to the main thread, causing any pending <a class="el" href="namespacefltk3.html#a541733012d24b25a080b88dabcc03ece" title="Waits until &quot;something happens&quot; and then returns. ">fltk3::wait()</a> call to terminate so that the main thread can retrieve the message and any pending redraws can be processed. </p>
<p>Multiple calls to <a class="el" href="group__fl__multithread.html#ga57ad2446eb494e5e235b268008ad1be4" title="Sends a message pointer to the main thread, causing any pending fltk3::wait() call to terminate so th...">fltk3::awake()</a> will queue multiple pointers for the main thread to process, up to a system-defined (typically several thousand) depth. The default message handler saves the last message which can be accessed using the <a class="el" href="group__fl__multithread.html#gacfd58519b3043a9a3625c79d9b156a40" title="The thread_message() method returns the last message that was sent from a child by the awake() method...">fltk3::thread_message()</a> function.</p>
<p>In the context of a threaded application, a call to <a class="el" href="group__fl__multithread.html#ga57ad2446eb494e5e235b268008ad1be4" title="Sends a message pointer to the main thread, causing any pending fltk3::wait() call to terminate so th...">fltk3::awake()</a> with no argument will trigger event loop handling in the main thread. Since it is not possible to call <a class="el" href="namespacefltk3.html#a105e0036971e3dd802d782c3ba3fdc02" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">fltk3::flush()</a> from a subsidiary thread, <a class="el" href="group__fl__multithread.html#ga57ad2446eb494e5e235b268008ad1be4" title="Sends a message pointer to the main thread, causing any pending fltk3::wait() call to terminate so th...">fltk3::awake()</a> is the best (and only, really) substitute.</p>
<p>See also: <a class="el" href="advanced.html#advanced_multithreading">Multithreading</a> </p>

</div>
</div>
<a class="anchor" id="gaa02c22e313b4819ebd65a0adc8ffc6e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fltk3::awake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga6d4af15d7c2d6deba77849428dfe21a6">fltk3::AwakeHandler</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See void awake(void* message=0). </p>
<p>Let the main thread know an update is pending and have it call a specific function.</p>
<p>Registers a function that will be called by the main thread during the next message handling cycle. Returns 0 if the callback function was registered, and -1 if registration failed. Over a thousand awake callbacks can be registered simultaneously.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fl__multithread.html#ga57ad2446eb494e5e235b268008ad1be4" title="Sends a message pointer to the main thread, causing any pending fltk3::wait() call to terminate so th...">fltk3::awake</a>(void* <a class="el" href="group__group__comdlg.html#gac46e6b327231a5886501bb45b42b5d44" title="Shows an information message dialog box. ">message</a>=0) </dd></dl>

</div>
</div>
<a class="anchor" id="ga3766ea2ba299968d3127970c06e0f88f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fltk3::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="group__fl__multithread.html#ga3766ea2ba299968d3127970c06e0f88f" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> method blocks the current thread until it can safely access FLTK widgets and data. </p>
<p>Child threads should call this method prior to updating any widgets or accessing data. The main thread must call <a class="el" href="group__fl__multithread.html#ga3766ea2ba299968d3127970c06e0f88f" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> to initialize the threading support in FLTK. <a class="el" href="group__fl__multithread.html#ga3766ea2ba299968d3127970c06e0f88f" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> will return non-zero if threading is not available on the platform.</p>
<p>Child threads must call <a class="el" href="group__fl__multithread.html#ga07d3d4965696f433c45ace9ff9895fa0" title="The unlock() method releases the lock that was set using the lock() method. ">unlock()</a> when they are done accessing FLTK.</p>
<p>When the <a class="el" href="namespacefltk3.html#a541733012d24b25a080b88dabcc03ece" title="Waits until &quot;something happens&quot; and then returns. ">wait()</a> method is waiting for input or timeouts, child threads are given access to FLTK. Similarly, when the main thread needs to do processing, it will wait until all child threads have called <a class="el" href="group__fl__multithread.html#ga07d3d4965696f433c45ace9ff9895fa0" title="The unlock() method releases the lock that was set using the lock() method. ">unlock()</a> before processing additional data.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if threading is available on the platform; non-zero otherwise.</dd></dl>
<p>See also: <a class="el" href="advanced.html#advanced_multithreading">Multithreading</a> </p>

</div>
</div>
<a class="anchor" id="gacfd58519b3043a9a3625c79d9b156a40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * fltk3::thread_message </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="group__fl__multithread.html#gacfd58519b3043a9a3625c79d9b156a40" title="The thread_message() method returns the last message that was sent from a child by the awake() method...">thread_message()</a> method returns the last message that was sent from a child by the <a class="el" href="group__fl__multithread.html#ga57ad2446eb494e5e235b268008ad1be4" title="Sends a message pointer to the main thread, causing any pending fltk3::wait() call to terminate so th...">awake()</a> method. </p>
<p>See also: <a class="el" href="advanced.html#advanced_multithreading">Multithreading</a> </p>

</div>
</div>
<a class="anchor" id="ga07d3d4965696f433c45ace9ff9895fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fltk3::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="group__fl__multithread.html#ga07d3d4965696f433c45ace9ff9895fa0" title="The unlock() method releases the lock that was set using the lock() method. ">unlock()</a> method releases the lock that was set using the <a class="el" href="group__fl__multithread.html#ga3766ea2ba299968d3127970c06e0f88f" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> method. </p>
<p>Child threads should call this method as soon as they are finished accessing FLTK.</p>
<p>See also: <a class="el" href="advanced.html#advanced_multithreading">Multithreading</a> </p>

</div>
</div>
</div><!-- contents -->
<!-- BEGIN FLTK HTML_FOOTER -->
 <!-- Generated for FLTK 3.0 by Doxygen -->
   <li class="footer">
     <!-- Generated for FLTK 3.0 by Doxygen -->
     &copy; 1998-2011 by Bill Spitzak and others. &nbsp;&nbsp;&nbsp;
     <a href="http://www.fltk.org"><img src="tiny.png" align="bottom" alt="FLTK"></a>
   </li>
  </ul>
 </div>
<hr class="footer"/>
<address class="footer"><small>
  <div align="left">
    <a href="http://www.fltk.org"><img src="tiny.png" align="bottom" alt="FLTK"></a>
    &copy; 1998-2011 by Bill Spitzak and others.&nbsp;&nbsp;&nbsp;
    Permission is granted to reproduce this manual or any portion for
    any purpose, provided this copyright and permission notice are preserved.
  </div>
</small></address>
<!-- END FLTK HTML_FOOTER (/body and /html follows...) -->
</body>
</html>
